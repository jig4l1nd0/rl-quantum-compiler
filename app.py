"""
RL Quantum Circuit Compiler - Gradio Web Application

This module provides a web-based interface for optimizing quantum circuits using
a trained PPO reinforcement learning agent. Users can input QASM 2.0 circuits
and the trained agent will apply its learned policy to optimize circuit depth
and gate count using Qiskit transpiler passes.

Features:
- Web interface for quantum circuit optimization
- Support for QASM 2.0 input format
- Real-time optimization metrics display
- Comparison between original and optimized circuits
- FastAPI integration for deployment health checks

Requirements:
- Trained PPO model file: 'ppo_quantum_compiler.zip'
- Gradio: Web interface framework
- FastAPI: Backend API framework
- Stable Baselines3: RL model loading
- Qiskit: Quantum circuit manipulation

Usage:
- Local: python app.py (launches on http://localhost:7860)
- Deployment: Supports Railway, Heroku, etc. with health check endpoint
"""

import gradio as gr
import numpy as np
from stable_baselines3 import PPO
from qiskit.circuit import QuantumCircuit
from qiskit.qasm2 import loads as qasm2_loads
import fastapi
import uvicorn
import os

# === MODEL LOADING AND INITIALIZATION ===
# The trained RL agent must be loaded before the web interface can function

# 1. Import the environment class for model deserialization
# SB3 requires the environment class to be available when loading saved models
from rl_compiler_env import QuantumCircuitEnv

# Path to the trained PPO model (generated by train.py)
MODEL_PATH = "ppo_quantum_compiler.zip"

# 2. Create a dummy environment instance
# This provides the observation/action space structure for model loading
# The actual circuits will be injected later during inference
dummy_env = QuantumCircuitEnv()

# 3. Load the pre-trained PPO agent with comprehensive error handling
try:
    if not os.path.exists(MODEL_PATH):
        # Provide clear error message if model hasn't been trained yet
        raise FileNotFoundError(
            f"Model file not found at {MODEL_PATH}. "
            "Please run train.py to generate the model."
        )

    print("Loading trained PPO model...")
    # PPO.load requires the environment structure to match training
    model = PPO.load(MODEL_PATH, env=dummy_env)
    print("Model loaded successfully.")

except FileNotFoundError:
    # Graceful degradation: app loads but compilation fails
    model = None
    print(
        f"WARNING: Model {MODEL_PATH} not found. "
        "Gradio will load, but compilation will fail."
    )


# === CORE CIRCUIT OPTIMIZATION LOGIC ===

def compile_circuit(qasm_string):
    """
    Optimize a quantum circuit using the trained RL agent.

    This function takes a QASM 2.0 string, converts it to a quantum circuit,
    injects it into the RL environment, and runs the trained PPO agent to
    apply optimization passes. The agent uses its learned policy to select
    transpiler passes that minimize circuit depth and gate count.

    Args:
        qasm_string (str): QASM 2.0 formatted quantum circuit description

    Returns:
        tuple: (optimized_qasm, original_qasm, metrics_summary)
            - optimized_qasm (str): QASM of the optimized circuit
            - original_qasm (str): QASM of the original circuit  
            - metrics_summary (str): Formatted optimization statistics

    Raises:
        Returns error messages in tuple format for graceful UI handling
    """
    # === INPUT VALIDATION ===
    if model is None:
        return (
            "Model not loaded.", 
            "", 
            "Please train the PPO agent (run train.py) and ensure "
            "'ppo_quantum_compiler.zip' is in the directory."
        )

    if not qasm_string:
        return (
            "Error: QASM input is empty.", 
            "", 
            "Please provide a QASM circuit."
        )

    # === CIRCUIT PARSING AND SETUP ===
    # 1. Parse QASM string into Qiskit circuit object
    try:
        # Use qasm2.loads for QASM 2.0 compatibility
        circuit = qasm2_loads(qasm_string)
    except Exception as e:
        print(f"QASM parsing error: {e}")
        return (
            f"Error: Invalid QASM input. {str(e)}", 
            "", 
            "Please check your QASM 2.0 syntax."
        )

    # 2. Extract initial circuit metrics for comparison
    try:
        initial_qasm = circuit.qasm()          # Original QASM representation
        initial_depth = circuit.depth()        # Circuit depth (critical path)
        initial_size = circuit.size()          # Total gate count
    except Exception as e:
        print(f"Circuit property error: {e}")
        return (
            f"Error: Could not analyze circuit. {str(e)}", 
            "", 
            "Circuit might be empty or invalid."
        )

    # === RL ENVIRONMENT INJECTION ===
    # 3. Prepare the user's circuit for RL optimization

    # Get the model's vectorized environment (DummyVecEnv wrapper)
    env = model.get_env()

    # Reset environment to initialize internal counters and state
    env.reset()

    # Access the actual environment instance (assumes single environment)
    env_instance = env.envs[0]  # DummyVecEnv with n_envs=1

    # Manually inject the user's circuit into the environment
    # This bypasses the random circuit generation in reset()
    env_instance.circuit = circuit                    # Set user's circuit
    env_instance.initial_depth = initial_depth        # Store initial metrics
    env_instance.initial_size = initial_size
    env_instance.prev_depth = initial_depth           # Initialize for reward calc
    env_instance.prev_size = initial_size
    env_instance.current_step = 0                     # Reset step counter

    # Generate observation vector for the user's circuit
    obs = env_instance._get_obs()  # 16D feature vector
    obs = np.array([obs])          # Wrap for DummyVecEnv compatibility

    # === RL OPTIMIZATION LOOP ===
    # 4. Run the trained agent to optimize the circuit

    terminated = truncated = False

    # The agent will take up to max_steps actions (default: 20)
    # Each action applies a specific transpiler pass to optimize the circuit
    while not terminated and not truncated:
        # Agent selects the best action based on its learned policy
        # deterministic=True ensures consistent results (no exploration)
        action, _states = model.predict(obs, deterministic=True)

        # Apply the selected transpiler pass and get new state
        obs, reward, terminated_list, info_list = env.step(action)

        # Extract results from vectorized environment format
        terminated = terminated_list[0]  # Episode finished flag
        info = info_list[0]              # Circuit metrics dictionary

    # === RESULTS EXTRACTION AND FORMATTING ===
    # 5. Extract the optimized circuit and calculate improvements

    final_circuit = env_instance.circuit       # Optimized quantum circuit
    final_qasm = final_circuit.qasm()          # Convert to QASM string
    final_depth = final_circuit.depth()        # Optimized circuit depth
    final_size = final_circuit.size()          # Optimized gate count

    # 6. Calculate optimization performance metrics
    # Percentage improvements (positive = better optimization)
    depth_reduction = (
        (initial_depth - final_depth) / initial_depth 
        if initial_depth > 0 else 0
    )
    size_reduction = (
        (initial_size - final_size) / initial_size 
        if initial_size > 0 else 0
    )

    # Format comprehensive metrics summary for display
    metrics = (
        f"--- Initial Circuit ---\n"
        f"Depth: {initial_depth}\n"
        f"Gate Count: {initial_size}\n\n"
        f"--- Optimized Circuit ---\n"
        f"Depth: {final_depth}\n"
        f"Gate Count: {final_size}\n\n"
        f"--- Performance ---\n"
        f"Depth Reduction: {depth_reduction * 100:.2f}%\n"
        f"Gate Reduction: {size_reduction * 100:.2f}%\n"
        f"Total Steps: {env_instance.current_step}"
    )

    return final_qasm, initial_qasm, metrics

# === GRADIO WEB INTERFACE SETUP ===

# Example QASM circuit for demonstration and testing
# This circuit intentionally includes optimization opportunities:
# - Redundant barriers that can be removed
# - Gate sequences that can be simplified
# - Multiple H-CNOT patterns that might be optimized
EXAMPLE_QASM = """
OPENQASM 2.0;
include "qelib1.inc";
qreg q[8];
creg c[8];
h q[0];
h q[1];
h q[2];
cx q[0],q[1];
rz(0.1) q[0];
cx q[1],q[2];
rz(0.2) q[1];
cx q[2],q[3];
cx q[3],q[4];
rz(0.3) q[2];
cx q[4],q[5];
cx q[5],q[6];
rz(0.4) q[3];
cx q[6],q[7];
cx q[7],q[0];
barrier q;
h q[0];
h q[1];
cx q[0],q[1];
rz(0.5) q[0];
cz q[1],q[2];
barrier q;
measure q -> c;
"""

# Create the main Gradio interface with modern styling
with gr.Blocks(theme=gr.themes.Monochrome()) as demo:
    # Header with application description and instructions
    gr.Markdown(
        """
        # ðŸ¤– RL Quantum Circuit Compiler (PPO Agent)

        Paste your QASM 2.0 circuit below. The Reinforcement Learning agent will apply
        its **learned policy** of Qiskit transpiler passes (up to 20 steps) to achieve 
        maximum depth reduction.
        """
    )

    # Main interface layout with input/output sections
    with gr.Row():
        # Left column: Input section
        with gr.Column(scale=2):
            # QASM input text area with syntax highlighting
            qasm_in = gr.Code(
                label="Input QASM (5-15 Qubits Recommended)",
                language="qasm",            # Syntax highlighting for QASM
                value=EXAMPLE_QASM,         # Pre-populated example
                lines=20                    # Text area height
            )
            # Primary action button to trigger optimization
            compile_btn = gr.Button("Compile Circuit", variant="primary")

        # Right column: Metrics display
        with gr.Column(scale=1):
            # Real-time optimization metrics and statistics
            metrics_out = gr.Textbox(
                label="Optimization Metrics",
                lines=15,                   # Match input height
                interactive=False           # Read-only display
            )

    # Bottom section: Side-by-side circuit comparison
    with gr.Row():
        # Original circuit display
        with gr.Column():
            qasm_initial_out = gr.Code(
                label="Initial Circuit QASM",
                language="qasm",            # Syntax highlighting
                lines=15,
                interactive=False           # Read-only
            )
        # Optimized circuit display
        with gr.Column():
            qasm_final_out = gr.Code(
                label="Optimized QASM (Agent Output)",
                language="qasm",            # Syntax highlighting
                lines=15,
                interactive=False           # Read-only
            )

    # Connect the compile button to the optimization function
    # When clicked, passes input QASM to compile_circuit() and updates outputs
    compile_btn.click(
        fn=compile_circuit,              # Function to call
        inputs=[qasm_in],               # Input components
        outputs=[qasm_final_out, qasm_initial_out, metrics_out]  # Output components
    )

# === FASTAPI INTEGRATION FOR DEPLOYMENT ===
# FastAPI provides production-ready deployment capabilities

# Create FastAPI application instance
app = fastapi.FastAPI()


@app.get("/health")
def health_check():
    """
    Health check endpoint for deployment platform monitoring.

    Many deployment platforms (Railway, Heroku, AWS, etc.) require a health
    check endpoint to verify the application is running correctly. This
    endpoint returns a simple status response.

    Returns:
        dict: Status indicator for monitoring systems
    """
    return {"status": "ok"}


# Mount the Gradio interface to the FastAPI app
# This allows the Gradio UI to be served alongside the API endpoints
app = gr.mount_gradio_app(app, demo, path="/")

# === APPLICATION ENTRY POINT ===
if __name__ == "__main__":
    # Local development server configuration
    # For production deployment, use a proper ASGI server like Gunicorn
    print("Launching Gradio app on http://0.0.0.0:7860")
    print("Health check available at: http://0.0.0.0:7860/health")
    print("Web interface available at: http://0.0.0.0:7860/")

    # Start the server with uvicorn ASGI server
    uvicorn.run(
        app,                    # FastAPI app instance
        host="0.0.0.0",        # Listen on all network interfaces
        port=7860              # Standard Gradio port
    )
